**1. this绑定原理？**

this 其实是上下文对象的一个属性，上下文对象属性除了 this 还有变量对象属性和作用域链属性。当执行函数时，会判断 memberExpression 是否是 reference 类型，如果是 reference 类型则判断 memberexpression 的base 属性是否是对象如果是对象，则将 this 指向此对象。其余的情况则将 this 指向 undefined，在非严格模式下，值为 `undefined` 的 this 会指向全局变量。当然this也可以通过 `apply, call, bind` 函数进行显示绑定。

**2. 作用域的理解**

JavaScript 中的作用域是词法(静态)作用域，与之对应的还有动态作用域。每一个函数都会创建一个新的作用域，无论函数在哪调用或者如何被调用，函数的词法作用域都是由函数**声明时**所处位置确定的。

**3. 闭包**

能够访问其他函数内部变量的函数称之为闭包，或者说子函数在外面，其父函数相应的作用域不会被释放。可以构造匿名自执行函数防止某些函数污染全局变量。

**4. 垃圾回收**

- 标记清除：当变量进入执行环境时，会被标记为“进入环境”，当变量离开执行环境时，会被标记为“离开环境”。只有标记为“离开环境”的变量才会被回收。
- 引用计数：统计变量声明后被引用的次数，当次数为0的变量进行清除。

**5.  原型链与继承**

原型链中有三个概念，分别是构造函数，实例，原型对象。构造函数拥有prototype属性指向它的原型对象，实例拥有`__proto__`属性指向它的构造函数的原型对象，原型对象拥有constructor和`__proto__`属性，本质上也是个实例，constructor指向的是它的构造函数，`__proto__`属性指向的是它的构造函数的原型对象，如果直接继承Object的话，那么指向的就是object构造函数的原型对象。

继承有构造函数继承，原型链继承，构造组合继承，寄生式继承，寄生组合继承。

**6. 对象的深浅拷贝**

- 浅拷贝：如果赋值类型为基本类型则直接赋值，如果是引用类型，则复制其引用地址。
- 深拷贝：
  - 可以通过JSON来实现深拷贝，但是无法拷贝function类型。
  - 如何赋值类型为基本类型则直接赋值，如果是引用类型，则遍历其元素，若元素为引用类型则递归调用深拷贝，如果元素为基本类型则直接赋值。当然为了防止对象中的某些属性相互引用的导致死递归的问题，可以通过维护一个map对象，将已完成的深拷贝对象存入其中，当需要递归调用深度拷贝函数时，先确定此拷贝对象未在map对象中。

**7. apply，call，bind的区别**

apply和call主要是给函数的this指定对应对象，并调用此函数。

apply接受的参数有两个，一个是指定的对象，第二个是函数的参数数组。

call接受的参数有多个，第一个是指定2.26的对象，第二个及n个代表函数的对应的参数。

bind主要是为函数this绑定对应的值，并返回绑定后的函数，指示返回，不会执行此函数。